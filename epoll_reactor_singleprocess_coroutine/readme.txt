epoll reactor 协程池
reactor 所有读写非阻塞，客户端的处理请求是在不同的事件处理函数中断断续续，
会导致处理逻辑分散，代码难以理解等问题。维护成本更高。

1.协程是用户态轻量级线程，调度开销极低
传统线程切换涉及内核态上下文切换，开销大（保存/恢复寄存器、内核栈、内存映射等）；
协程在用户态调度，切换只涉及少量寄存器和栈指针修改，没有进入内核，极大减少了调度延迟；
2. 协程可以更细粒度地控制并发逻辑
协程用 yield 显式挂起，能准确在IO不可用时切换，避免线程阻塞；
线程阻塞时，整个线程被挂起，CPU不能利用起来；协程挂起时，调度器可以直接切换到其他协程，提高CPU利用率；
3. 减少线程数量，避免频繁上下文切换和内存开销
传统多线程并发时，线程数目大，内核频繁切换线程，带来性能损耗；
协程在一个或少量线程内管理成千上万个轻量任务，避免了大量线程上下文切换；
4. 与epoll高效配合，实现非阻塞IO的无阻塞调度
epoll 监控多个socket的IO事件，协程在等待IO时挂起，不浪费CPU；
一旦IO就绪，调度器恢复对应协程，处理逻辑快速切换，减少等待时间；
5. 内存和栈空间节省
线程通常需要分配较大的栈空间（比如1MB），而协程栈可以非常小（几KB甚至更小）；
这样可以在有限内存中支持大量并发任务，避免OOM或性能下降；
6. 协程切换更灵活，调度更高效
传统线程调度由操作系统决定，时间片和优先级调度，容易产生线程抢占导致性能波动；
协程由程序自身控制挂起和恢复，调度更加可控和确定。

g++ -I../echo -I../epoll_common -I../corotine -o epollreactorsingleprocesscorouline.out  epollreactorsingleprocesscorouline.cpp